<!DOCTYPE html>
<html>
<head>
  <title>Gomoku Multiplayer</title>
  <style>
    body {
      background-color: #f8f8f8;
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 30px;
    }

    #board {
      border: 2px solid #000;
      background-color: #f2d48f;
    }

    .text {
      position: absolute;
      right: 100px;
      top: 150px;
      font-size: 50px;
      font-family: "Monotype Corosiva";
      color: #f5f5f5;
    }

    .my-button {
      position: absolute;
      background-color: #f2d48f;
      border: 2px solid black;
      border-radius: 8px;
      top: 300px;
      left: 725px;
      width: 175px;
      height: 50px;
      cursor: pointer;
    }
  </style>
  <script src="https://unpkg.com/netplayjs@0.4.1/dist/netplay.js"></script>
</head>
<body style="background-color:#49402B;">
  <div>
    <div class="text"><b>Nathan's Gomoku Game</b></div>
  </div>
  <canvas id="board" width="600" height="600"></canvas>
  <button class="my-button" onclick="resetBoard()"><b>New Game</b></button>

  <script>
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');

    const gridSize = 31.6;
    const boardSize = 19;
    const margin = gridSize / 2;

    const BLACK = '#000';
    const WHITE = '#fff';

    let stones = createEmptyBoard();
    let currentPlayer = BLACK;
    let gameOver = false;

    const game = new netplayjs.Game();

    game.on('input', (player, input) => {
      if (player === game.getLocalPlayer() && !gameOver) {
        const { x, y } = input.mouse();
        const col = Math.floor(x / gridSize);
        const row = Math.floor(y / gridSize);

        if (stones[row][col] === null) {
          stones[row][col] = currentPlayer;
          currentPlayer = currentPlayer === BLACK ? WHITE : BLACK;
          game.emit('state', stones);
          checkWin(row, col);
          drawBoard();
        }
      }
    });

    game.on('state', (state) => {
      stones = state;
      drawBoard();
    });

    game.on('join', () => {
      game.emit('state', stones);
    });

    function createEmptyBoard() {
      return Array.from(Array(boardSize), () => Array(boardSize).fill(null));
    }

    function drawBoard() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.beginPath();
      for (let i = 0; i < boardSize; i++) {
        const y = i * gridSize + margin;
        ctx.moveTo(margin, y);
        ctx.lineTo(canvas.width - margin, y);
      }
      for (let j = 0; j < boardSize; j++) {
        const x = j * gridSize + margin;
        ctx.moveTo(x, margin);
        ctx.lineTo(x, canvas.height - margin);
      }
      ctx.strokeStyle = '#000';
      ctx.stroke();

      for (let row = 0; row < boardSize; row++) {
        for (let col = 0; col < boardSize; col++) {
          const stoneX = col * gridSize + margin;
          const stoneY = row * gridSize + margin;

          if (stones[row][col] === BLACK) {
            drawStone(stoneX, stoneY, BLACK);
          } else if (stones[row][col] === WHITE) {
            drawStone(stoneX, stoneY, WHITE);
          }
        }
      }
    }

    function drawStone(x, y, color) {
      ctx.beginPath();
      ctx.arc(x, y, gridSize / 2.5, 0, 2 * Math.PI);
      ctx.fillStyle = color;
      ctx.fill();
    }

    function checkWin(row, col) {
      const directions = [
        [1, 0], // Horizontal
        [0, 1], // Vertical
        [1, 1], // Diagonal (/)
        [1, -1] // Diagonal (\)
      ];

      for (const [dx, dy] of directions) {
        let count = 1;

        // Check in both directions
        for (let i = 1; i <= 4; i++) {
          const nx = row + i * dx;
          const ny = col + i * dy;

          if (
            nx >= 0 &&
            nx < boardSize &&
            ny >= 0 &&
            ny < boardSize &&
            stones[nx][ny] === stones[row][col]
          ) {
            count++;
          } else {
            break;
          }
        }

        for (let i = 1; i <= 4; i++) {
          const nx = row - i * dx;
          const ny = col - i * dy;

          if (
            nx >= 0 &&
            nx < boardSize &&
            ny >= 0 &&
            ny < boardSize &&
            stones[nx][ny] === stones[row][col]
          ) {
            count++;
          } else {
            break;
          }
        }

        if (count >= 5) {
          gameOver = true;
          const winner = stones[row][col];
          alert(`${winner} wins!`);
          game.reset();
          resetBoard();
          break;
        }
      }
    }

    function resetBoard() {
      stones = createEmptyBoard();
      currentPlayer = BLACK;
      gameOver = false;
      drawBoard();
    }

    drawBoard();
    game.connect('gomoku-room');
  </script>
</body>
</html>
