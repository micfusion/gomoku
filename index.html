<!DOCTYPE html>
<html>
<head>
  <title>Gomoku Game</title>
  <style>
    body {
      background-color: #49402B;
      font-family: "Monotype Corosiva", Arial, sans-serif;
      margin: 0;
      padding: 30px;
    }

    #board {
      border: 2px solid #000;
      background-color: #f2d48f;
    }

    .text {
      position: absolute;
      right: 100px;
      top: 150px;
      font-size: 50px;
      color: #f5f5f5;
    }

    .my-button {
      position: absolute;
      background-color: #f2d48f;
      border: 2px solid black;
      border-radius: 8px;
      top: 300px;
      left: 725px;
      width: 175px;
      height: 50px;
      cursor: pointer;
    }
  </style>
  <script src="https://unpkg.com/netplayjs@0.4.1/dist/netplay.js"></script>
</head>
<body>
  <div>
    <div class="text"><b>Nathan's Gomoku Game</b></div>
  </div>
  <canvas id="board" width="600" height="600"></canvas>
  <button class="my-button" onclick="startMatchmaking()"><b>Start Matchmaking</b></button>

  <script>
    class GomokuGame extends netplayjs.Game {
      static timestep = 1000 / 60;
      static canvasSize = { width: 600, height: 600 };

      constructor(canvas, players) {
        super(canvas, players);
        this.boardSize = 19;
        this.gridSize = canvas.width / this.boardSize;
        this.stones = Array.from(Array(this.boardSize), () => Array(this.boardSize).fill(null));
        this.isPlayerOne = true;
      }

      tick(playerInputs) {
        for (const [player, input] of playerInputs.entries()) {
          if (input.touches.length > 0) {
            const rect = this.canvas.getBoundingClientRect();
            const x = input.touches[0].x - rect.left;
            const y = input.touches[0].y - rect.top;
            const col = Math.floor(x / this.gridSize);
            const row = Math.floor(y / this.gridSize);
            if (this.isValidMove(row, col)) {
              this.placeStone(row, col, player.getID());
              this.checkWin(row, col, player);
            }
          }
        }
      }

      draw(canvas) {
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        for (let row = 0; row < this.boardSize; row++) {
          for (let col = 0; col < this.boardSize; col++) {
            const stoneX = col * this.gridSize + this.gridSize / 2;
            const stoneY = row * this.gridSize + this.gridSize / 2;

            if (this.stones[row][col] === 0) {
              ctx.fillStyle = "black";
              ctx.beginPath();
              ctx.arc(stoneX, stoneY, this.gridSize / 2.5, 0, 2 * Math.PI);
              ctx.fill();
            } else if (this.stones[row][col] === 1) {
              ctx.fillStyle = "white";
              ctx.beginPath();
              ctx.arc(stoneX, stoneY, this.gridSize / 2.5, 0, 2 * Math.PI);
              ctx.fill();
            }
          }
        }
      }

      placeStone(row, col, playerID) {
        this.stones[row][col] = playerID;
      }

      isValidMove(row, col) {
        return this.stones[row][col] === null;
      }

      checkWin(row, col, player) {
        const directions = [
          [1, 0], // Horizontal
          [0, 1], // Vertical
          [1, 1], // Diagonal (top-left to bottom-right)
          [1, -1], // Diagonal (top-right to bottom-left)
        ];

        for (const [dx, dy] of directions) {
          let count = 1;

          for (let i = 1; i < 5; i++) {
            const newRow = row + i * dx;
            const newCol = col + i * dy;

            if (
              newRow < 0 ||
              newRow >= this.boardSize ||
              newCol < 0 ||
              newCol >= this.boardSize ||
              this.stones[newRow][newCol] !== player.getID()
            ) {
              break;
            }

            count++;
          }

          for (let i = 1; i < 5; i++) {
            const newRow = row - i * dx;
            const newCol = col - i * dy;

            if (
              newRow < 0 ||
              newRow >= this.boardSize ||
              newCol < 0 ||
              newCol >= this.boardSize ||
              this.stones[newRow][newCol] !== player.getID()
            ) {
              break;
            }

            count++;
          }

          if (count >= 5) {
            alert(`Player ${player.getID()} wins!`);
            this.resetGame();
            break;
          }
        }
      }

      resetGame() {
        this.stones = Array.from(Array(this.boardSize), () => Array(this.boardSize).fill(null));
      }
    }

    function startMatchmaking() {
      const canvas = document.getElementById("board");
      const game = new GomokuGame(canvas);
      const wrapper = new netplayjs.RollbackWrapper(game);

      wrapper.startMatchmaking().then((players) => {
        game.setPlayers(players);
        game.start();
      });
    }
  </script>
</body>
</html>

